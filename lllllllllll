-- Sistema de Protecci√≥n Anti-Pirater√≠a con Debug
print("=== INICIANDO SISTEMA DE PROTECCI√ìN ===")

-- Configuraci√≥n
local CONFIG = {
    WEBHOOK_UNAUTHORIZED = "https://discord.com/api/webhooks/1448814494359748718/vhzjZ_yzx-hX1u5Hb4dzwlMbDY-CAFaK88IUfs2xBedwVPTSRbtrmBIeVt5KkfPI9Ddp",
    WEBHOOK_AUTHORIZED = "https://discord.com/api/webhooks/1448813123225128980/NypA6Ijvw3dBVta68xvtc9sjrXiIbyU8wisGxZbS6vcgc-WpQVDjNnjviq62RuAhaeIQ",
    WHITELIST_URL = "https://raw.githubusercontent.com/CoronaBlanca/Whitelist-Users/refs/heads/main/SC%20Booster",
    CHECK_INTERVAL = 300,
}

-- Servicios
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local MarketplaceService = game:GetService("MarketplaceService")
local UserInputService = game:GetService("UserInputService")

print("‚úÖ Servicios cargados")

-- Obtener informaci√≥n del ejecutor con mejor detecci√≥n
local function getExecutorName()
    if identifyexecutor then
        local executor = identifyexecutor()
        if executor then
            return executor
        end
    end
    
    if getexecutorname then
        return getexecutorname()
    elseif DELTA_LOADED or (getgenv and getgenv().delta) then
        return "Delta"
    elseif SOLARA_LOADED or (getgenv and getgenv().solara) then
        return "Solara"
    elseif WAVE_LOADED then
        return "Wave"
    elseif syn and not is_sirhurt_closure and not pebc_execute then
        return "Synapse X"
    elseif ELECTRON_LOADED then
        return "Electron"
    elseif isfluxus then
        return "Fluxus"
    elseif KRNL_LOADED then
        return "Krnl"
    elseif is_sirhurt_closure then
        return "SirHurt"
    else
        return "Unknown Executor"
    end
end

-- Obtener informaci√≥n del sistema
local function getSystemInfo()
    local clientId = game:GetService("RbxAnalyticsService"):GetClientId()
    local hwid = (gethwid and gethwid()) or clientId
    
    local info = {
        executor = getExecutorName(),
        clientId = clientId,
        hwid = hwid,
        userId = LocalPlayer.UserId,
        username = LocalPlayer.Name,
        displayName = LocalPlayer.DisplayName,
        accountAge = LocalPlayer.AccountAge,
        premium = LocalPlayer.MembershipType == Enum.MembershipType.Premium,
        platform = UserInputService.TouchEnabled and not (UserInputService.KeyboardEnabled or UserInputService.MouseEnabled) and "Mobile" 
                   or (UserInputService.KeyboardEnabled and UserInputService.MouseEnabled and "PC" 
                   or (UserInputService.GamepadEnabled and "Console" or "Unknown"))
    }
    
    print("=== TUS DATOS ===")
    print("HWID:", info.hwid)
    print("Client ID:", info.clientId)
    print("User ID:", info.userId)
    print("Username:", info.username)
    print("Executor:", info.executor)
    print("================")
    
    return info
end

-- Enviar webhook
local function sendWebhook(webhookUrl, embedData)
    local success, result = pcall(function()
        local payload = HttpService:JSONEncode(embedData)
        
        local requestFunc = http_request or request or HttpPost or syn and syn.request
        
        if not requestFunc then
            warn("‚ùå Tu executor no soporta HTTP requests")
            return false
        end
        
        requestFunc({
            Url = webhookUrl,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = payload
        })
        
        return true
    end)
    
    return success
end

-- Enviar notificaci√≥n de acceso no autorizado
local function notifyUnauthorized(info, reason)
    print("üö® Enviando notificaci√≥n de acceso NO AUTORIZADO...")
    
    local embedData = {
        avatar_url = "https://i.pinimg.com/564x/75/43/da/7543daab0a692385cca68245bf61e721.jpg",
        embeds = {{
            author = {
                name = "‚ùå Acceso No Autorizado",
                url = "https://roblox.com"
            },
            description = string.format(
                "__[Player Info](https://www.roblox.com/users/%d)__\n" ..
                "**Display Name:** %s\n" ..
                "**Username:** %s\n" ..
                "**User ID:** %d\n" ..
                "**Client ID:** `%s`\n" ..
                "**HWID:** `%s`\n" ..
                "**Executor:** %s\n\n" ..
                "**Raz√≥n:** %s",
                info.userId, info.displayName, info.username, 
                info.userId, info.clientId, info.hwid, info.executor, reason
            ),
            color = 16711680,
            thumbnail = {
                url = string.format("https://www.roblox.com/headshot-thumbnail/image?userId=%d&width=150&height=150&format=png", info.userId)
            },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%S")
        }}
    }
    
    local success = sendWebhook(CONFIG.WEBHOOK_UNAUTHORIZED, embedData)
    
    if success then
        print("‚úÖ Notificaci√≥n de NO AUTORIZADO enviada")
    else
        warn("‚ùå Error al enviar notificaci√≥n")
    end
end

-- Enviar log de ejecuci√≥n exitosa
local function logExecution(info)
    print("üìä Enviando log de ejecuci√≥n AUTORIZADA...")
    
    local gameName = "Unknown Game"
    pcall(function()
        gameName = MarketplaceService:GetProductInfo(game.PlaceId).Name
    end)
    
    local embedData = {
        avatar_url = "https://i.pinimg.com/564x/75/43/da/7543daab0a692385cca68245bf61e721.jpg",
        embeds = {{
            author = {
                name = "‚úÖ Script Ejecutado Exitosamente",
                url = "https://roblox.com"
            },
            description = string.format(
                "__[Player Info](https://www.roblox.com/users/%d)__\n" ..
                "**Display Name:** %s\n" ..
                "**Username:** %s\n" ..
                "**User ID:** %d\n" ..
                "**Account Age:** %d days\n" ..
                "**Membership:** %s\n" ..
                "**Platform:** %s\n\n" ..
                "__[Game Info](https://www.roblox.com/games/%d)__\n" ..
                "**Game:** %s\n" ..
                "**Game ID:** %d\n" ..
                "**Executor:** %s",
                info.userId, info.displayName, info.username, 
                info.userId, info.accountAge, 
                info.premium and "Premium" or "No Premium",
                info.platform, game.PlaceId, gameName, 
                game.PlaceId, info.executor
            ),
            color = 65280,
            thumbnail = {
                url = string.format("https://www.roblox.com/headshot-thumbnail/image?userId=%d&width=150&height=150&format=png", info.userId)
            },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%S")
        }}
    }
    
    local success = sendWebhook(CONFIG.WEBHOOK_AUTHORIZED, embedData)
    
    if success then
        print("‚úÖ Log de AUTORIZADO enviado")
    else
        warn("‚ùå Error al enviar log")
    end
end

-- Kick seguro
local function secureKick(reason)
    warn("‚õî KICKEANDO: " .. reason)
    task.wait(2)
    LocalPlayer:Kick("‚ö†Ô∏è " .. reason)
    task.wait(1)
    while true do end
end

-- Verificaci√≥n de whitelist
local function checkWhitelist()
    print("üîç Descargando whitelist desde GitHub...")
    
    local info = getSystemInfo()
    
    local success, whitelist = pcall(function()
        local response = game:HttpGet(CONFIG.WHITELIST_URL)
        print("üìÑ Whitelist descargada, procesando...")
        return loadstring(response)()
    end)
    
    if not success then
        warn("‚ùå Error al descargar whitelist:", whitelist)
        notifyUnauthorized(info, "Error al cargar whitelist desde GitHub")
        secureKick("Error de verificaci√≥n. Contacta al desarrollador.")
        return false
    end
    
    if type(whitelist) ~= "table" then
        warn("‚ùå Whitelist no es una tabla v√°lida")
        notifyUnauthorized(info, "Whitelist corrupta o mal formateada")
        secureKick("Error de verificaci√≥n. Contacta al desarrollador.")
        return false
    end
    
    print("üìã Verificando " .. #whitelist .. " entradas en whitelist...")
    
    -- Verificar si el usuario est√° en la whitelist
    for i, entry in ipairs(whitelist) do
        print(string.format("Checking entry %d: HWID match=%s, ClientID match=%s", 
            i, 
            tostring(entry.hwid == info.hwid),
            tostring(entry.clientID == info.clientId)
        ))
        
        if entry.hwid == info.hwid and entry.clientID == info.clientId then
            print("‚úÖ ENCONTRADO EN WHITELIST - Acceso concedido")
            return true, info
        end
    end
    
    print("‚ùå NO encontrado en whitelist")
    notifyUnauthorized(info, "HWID/Client ID no encontrado en whitelist")
    secureKick("Acceso denegado. No tienes licencia v√°lida.")
    return false
end

-- Protecci√≥n contra output leaks (simplificada para debug)
local function protectOutput()
    print("üõ°Ô∏è Activando protecciones anti-leak...")
    task.spawn(function()
        local blockedPatterns = {"discord.com/api/webhooks"}
        
        local function checkAndBlock(str)
            if not str then return end
            local lower = string.lower(tostring(str))
            for _, pattern in ipairs(blockedPatterns) do
                if string.find(lower, pattern, 1, true) then
                    warn("üö® Intento de leak detectado y bloqueado")
                    while true do end
                end
            end
        end
        
        if hookfunction then
            hookfunction(print, function(...)
                local args = {...}
                for _, arg in ipairs(args) do
                    checkAndBlock(arg)
                end
            end)
        end
    end)
    print("‚úÖ Protecciones activadas")
end

-- Verificaci√≥n continua
local function startContinuousCheck()
    task.spawn(function()
        print("‚è∞ Verificaci√≥n continua iniciada (cada 5 minutos)")
        while task.wait(CONFIG.CHECK_INTERVAL) do
            print("üîÑ Re-verificando whitelist...")
            local authorized = checkWhitelist()
            if not authorized then
                secureKick("Licencia revocada o expirada")
            end
        end
    end)
end

-- Inicializar sistema de protecci√≥n
local function initialize()
    print("üîí INICIANDO VERIFICACI√ìN DE LICENCIA...")
    
    -- Obtener info del sistema primero
    local info = getSystemInfo()
    
    -- Verificar whitelist
    print("üì° Conectando con servidor de licencias...")
    local authorized, verifiedInfo = checkWhitelist()
    
    if not authorized then
        print("‚ùå VERIFICACI√ìN FALLIDA - Script bloqueado")
        return false
    end
    
    print("‚úÖ LICENCIA VERIFICADA - Acceso concedido")
    
    -- Log de ejecuci√≥n exitosa
    logExecution(verifiedInfo or info)
    
    -- Activar protecciones
    protectOutput()
    
    -- Iniciar verificaci√≥n continua
    startContinuousCheck()
    
    return true
end

-- EJECUTAR VERIFICACI√ìN
print("=" .. string.rep("=", 50))
local authorized = initialize()
print("=" .. string.rep("=", 50))

if not authorized then
    warn("‚õî SCRIPT BLOQUEADO - No autorizado")
    return
end

print("üöÄ CARGANDO SCRIPT PRINCIPAL...")

-- ====================================
-- TU C√ìDIGO PRINCIPAL COMIENZA AQU√ç
-- ====================================

-- Funciones del script original
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local function unequipAllPets()
    local petsFolder = LocalPlayer.petsFolder
    for _, folder in pairs(petsFolder:GetChildren()) do
        if folder:IsA("Folder") then
            for _, pet in pairs(folder:GetChildren()) do
                ReplicatedStorage.rEvents.equipPetEvent:FireServer("unequipPet", pet)
            end
        end
    end
    task.wait(0.1)
end

local function equipPet(petName)
    unequipAllPets()
    task.wait(0.01)
    for _, pet in pairs(LocalPlayer.petsFolder.Unique:GetChildren()) do
        if pet.Name == petName then
            ReplicatedStorage.rEvents.equipPetEvent:FireServer("equipPet", pet)
        end
    end
end

local function findMachine(machineName)
    local machine = workspace.machinesFolder:FindFirstChild(machineName)
    if not machine then
        for _, folder in pairs(workspace:GetChildren()) do
            if folder:IsA("Folder") and folder.Name:find("machines") then
                machine = folder:FindFirstChild(machineName)
                if machine then break end
            end
        end
    end
    return machine
end

local function pressE()
    local VIM = game:GetService("VirtualInputManager")
    VIM:SendKeyEvent(true, "E", false, game)
    task.wait(0.1)
    VIM:SendKeyEvent(false, "E", false, game)
end

-- Cargar UI
print("üé® Cargando interfaz...")
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/memejames/elerium-v2-ui-library//main/Library", true))()
local Window = Library:AddWindow("Beamed v2 (Paid)", {
    main_color = Color3.fromRGB(15, 15, 15),
    min_size = Vector2.new(430, 530),
    can_resize = false
})

print("‚úÖ SCRIPT CARGADO COMPLETAMENTE")

-- Aqu√≠ contin√∫a tu UI y funcionalidades...
